#!/usr/bin/env python

import json
import numpy as np
import time
import logging
import glob
import shutil
import os
from feature_extractor import FeatureExtractor
from basic_feature_extractor import BasicFeatureExtractor
from collections import defaultdict   

class BasicFeaturePlusWIFIExtractor(FeatureExtractor):
    """
    Basic feature extractor extracts time and loc from a validated json user log as csv format.
    """

    # uuid
    # 0 for guid generated by app
    # 1 for imei
    UID_INDEX = 1
    
    # Maximum number of WIFI networks in the list odf crossed networks
    MAX_N_WNET = 1023
    
    # time
    one_day_second = 24 * 60 * 60
    seven_days_second = one_day_second * 7
    two_pi_by_one_day_second = 2 * np.pi / one_day_second
    two_pi_by_seven_days_second = 2 * np.pi / seven_days_second
        
    # i/o 
    src_paths = "./data/mixs_logs/json/usrs/*/all/all_in_one_validated_log.json"
    dst_dir = "./features"
    

    def __init__(self, src_paths = src_paths, dst_dir = dst_dir):
        
        """
        Arguments:
        - `src_paths`: source paths in which logs of a user are assembled to one file.
        - `dst_dir`: distination directory
        """
        super(BasicFeaturePlusWIFIExtractor, self).__init__()
        
        logger = logging.getLogger("BasicFeatureExtractor")
        logger.setLevel(logging.INFO)
        logging.basicConfig()
        self.logger = logger

        pass

    def extract(self, ):
        """
        extract json data
        """
        self.logger.info("extract starts")
        st = time.time()

        self._delete_old_data()
        user_log_paths = glob.glob(self.src_paths)
        for user_log_path in user_log_paths: # for each user
            self._extract_usr_log(user_log_path)
            pass
    
        et = time.time()

        self.logger.info("%f [s]" % (et - st))
        self.logger.info("extract finished")
        pass
        
    def _extract_usr_log(self, src_path):
        """
        Arguments:
        - `src_path`: source path
        """
        # read
        fpin = open(src_path)
        json_logs = json.load(fpin)
        fpin.close()

        # uid
        uid = self._extract_uid(json_logs)

        # extract data
        self.logger.info("extracting %s" % uid)
        
        # lognfo
        log_info = json_logs["logInfo"]
        time_seq = log_info.keys()
        time_seq.sort()
        
        data = ""
        
        
        
        # Build a set wifi networks
        #dict((a[el],el) for el in reversed(range(len(a)))
        dic_wnet=defaultdict(lambda: 0)
        self.logger.info("Occurences ---> %s" % len(time_seq))
        for t in time_seq:
            log=log_info[t];
            if "wifiAps" in log:
                wifiAps = log["wifiAps"]
                #self.logger.info("         %s" % len(wifiAps))
                for wnet in wifiAps:
                    dic_wnet[wnet["bssId"]]+=1
                    
                pass              
            pass
        pass
        list_wnet=sorted(dic_wnet, key=dic_wnet.get, reverse=True)[0:self.MAX_N_WNET] # takes the MAX_N_WNET most frequent networks
              
        
        
        
        
        
        # convert the set into dictionary of wifi networks {wnet1:idx1 , wnet2:idx2}
        #   idx is the corresponding index in the mask array
        self.dic_wnet = {list_wnet[e]:e for e in range(len(list_wnet))}
        
        # header
        data += self._create_header()
        
        # data
        for t in time_seq:
            l = self._create_line(log_info, t)
            data += l
            data += "\n"
            pass
        
        data = data.strip()

        # save
        self._save(data, uid)
        
        pass


    def _create_line(self, log_info, t):
        """
        Arguments:
        - `src_path`: source path
        """

        l = ""
        appname = log_info[t]["appLaunch"]["appName"]
        l += appname + ","
        l += self._extract_location_xyz(log_info[t]) + ","
        l += self._convert_timestamp_2_periodic_time(t) + ","
        l += self._extract_wifi_networks(log_info[t]) 

        return l

    def _create_header(self, ):
        """
        """
        header = "label,lat,lon,alt,daily_periodicity_x,daily_periodicity_y,weekly_periodicity_x,weekly_periodicity_y,wifiConnectedAp_bssId,wifiAps_strongest,wifiAps_available\n"
        return header


    def _extract_uid(self, json_logs):
        """
        
        Arguments:
        - `json_logs`: json log for a user
        """
        
        return json_logs["baseInfo"][self.UID_INDEX]["value"]


        pass

    def _extract_appname(self, log):
        """
        extract appname.
        if appLaunch field does not exist, skip that log but such a log is few like 0.0...01 %.
        
        Arguments:
        - `log`: log at t
        """
        appname = ""
        if "appLaunch" in log:
            appname = log["appLaunch"]["appName"]
        else:
            self.logger.info("no applaunch field")
            self.logger.info(log["event"])
            pass        
        
        return appname

    def _extract_location_xyz(self, log):
        """
        extract location info.
        if location field does not exist, (x,y,x) = (0,0,0)

        Arguments:
        - `log`: log at t
        """

        if "location" in log:
            x = log["location"]["latitude"]
            y = log["location"]["longitude"]
            z = log["location"]["altitude"]
        else:
            self.logger.debug("NaN case")
            x = "NaN" # matlab Nan?
            y = "NaN"
            z = "NaN"
            pass
        return str(x) + "," + str(y) + "," + str(z)

    def _extract_wifi_networks(self, log):
        """
        extract wifi info.
      
        Arguments:
        - `log`: log at t
        """
        # connect wifi
        if "wifiConnectedAp" in log:
            wifiConnectedAp_bssId = log["wifiConnectedAp"]["bssId"]
            if wifiConnectedAp_bssId == "00:00:00:00:00:00":
                self.logger.debug("NaN case")
                wifiConnectedAp_bssId = "NaN" 
            pass
        else:
            self.logger.debug("NaN case")
            wifiConnectedAp_bssId = "NaN"
            pass
        mask_wnet = 0; #mask_wnet  mask converted into long
        if "wifiAps" in log:
            wifiAps = log["wifiAps"]
            ##  best network
            best_level=-10000 #initial very low value
            wifiAps_strongest = "NaN"
            for wnet in wifiAps:
                
                if wnet["bssId"] in self.dic_wnet:
                    mask_wnet=mask_wnet | 1<<self.dic_wnet[wnet["bssId"]] # binary mask get 1 at index correponding to wnet network
                if wnet["level"]>best_level: 
                    wifiAps_strongest=wnet["bssId"]
                    best_level=wnet["level"]
                pass
            pass  
            
            ## network mask
            
        else:
            self.logger.debug("NaN case")
            wifiAps_strongest = "NaN" 
            pass   
            
        return  wifiConnectedAp_bssId + "," + wifiAps_strongest + "," + str(hex(mask_wnet))
        
    def _convert_timestamp_2_periodic_time(self, timestamp):
        """
        convert ${unix time}${millisecond} to periodic information on a weekly basis.
        return as string as format x,y

        Arguments:cd py 
        - `timestamp`: unix time added millisecond
        """
        
        l = ""

        # daily periodic
        theta = self.two_pi_by_one_day_second * (int(timestamp[0:-3]) % self.one_day_second)
        #x = 1 + np.cos(theta)
        #y = 1 + np.sin(theta)
        x = np.cos(theta)
        y = np.sin(theta)
        l += str(x) + "," + str(y)
        l += ","

        # weekly periodic
        theta = self.two_pi_by_seven_days_second * (int(timestamp[0:-3]) % self.seven_days_second)
        # no need plus one?
        #x = 1 + np.cos(theta)
        #y = 1 + np.sin(theta)
        x = np.cos(theta)
        y = np.sin(theta)
        l += str(x) + "," + str(y)

        return l
    
    def _save(self, data, uid):
        """
        
        Arguments:
        - `data`: saved dataset
        - `uid`: user id
        """
        fout = "%s/%s.dat" % (self.dst_dir, uid)
        fpout = open(fout, "w")
        fpout.write(data)
        fpout.close()
        pass

    def _delete_old_data(self, ):
        """
        """
        for fin in glob.glob("%s/*" % (self.dst_dir)):
            os.remove(fin)
            pass
        
def main():
    # i/o 
    src_paths = "./data/mixs_logs/json/usrs/*/all/all_in_one_validated_log.json"
    dst_dir = "./features"

    extractor = BasicFeaturePlusWIFIExtractor(src_paths = src_paths, dst_dir = dst_dir)
    extractor.extract()

if __name__ == '__main__':
    main()


    
